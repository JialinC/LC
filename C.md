# 静态库与动态库的制作与使用

---

## 1. 静态库（Static Library）

### ✅ 命名规则  
- **Linux**: `libxxx.a`  
  - `lib`: 固定前缀  
  - `xxx`: 库名称（自定义）  
  - `.a`: 后缀  
- **Windows**: `libxxx.lib`

### ✅ 制作流程  
1. **编译源文件为目标文件（.o）**  
   ```bash
   gcc -c a.c b.c
   ```

2. **使用 ar 工具打包为静态库**  
   ```bash
   ar rcs libxxx.a a.o b.o
   ```

### ✅ 使用方法  
编译主程序时链接静态库：  
```bash
gcc main.c -L. -lxxx -o main
```
说明：  
- `-L.` 指定库所在路径  
- `-lxxx` 链接名为 `libxxx.a` 的库  

---

## 2. 动态库（Dynamic Library）

### ✅ 命名规则  
- **Linux**: `libxxx.so`  
  - `lib`: 固定前缀  
  - `xxx`: 自定义名  
  - `.so`: 动态库后缀  
- **Windows**: `libxxx.dll`

### ✅ 制作流程  
1. **编译为位置无关代码（fPIC）**  
   ```bash
   gcc -fPIC -c a.c b.c
   ```

2. **生成共享库（.so）**  
   ```bash
   gcc -shared a.o b.o -o libxxx.so
   ```

### ✅ 使用方法  
编译主程序：  
```bash
gcc main.c -L. -lxxx -o main
```
运行程序前设置动态库路径：  
```bash
export LD_LIBRARY_PATH=.
```

---

## 3. 静态库 vs 动态库

| 特性 | 静态库 `.a` | 动态库 `.so` |
|------|-------------|---------------|
| 链接方式 | 编译时链接 | 运行时链接 |
| 是否打包进程序 | 是 | 否 |
| 发布是否需额外库 | 否 | 是 |
| 内存占用 | 高（每个程序各自加载） | 低（共享加载） |
| 更新方式 | 需重新编译程序 | 可直接替换库 |
| 优点 | 移植方便，无依赖 | 更新方便，节省空间 |
| 缺点 | 更新麻烦，程序体积大 | 运行环境需有库文件 |

---

## 🎯 得分点总结
- ✅ 命名规范清楚
- ✅ 制作命令齐全：`gcc -c`, `ar`, `-fPIC`, `-shared`
- ✅ 使用方式包含 `-L`, `-l`，和 `LD_LIBRARY_PATH`
- ✅ 对比有条理，涵盖运行机制、部署、内存等方面

# GDB 常见调试命令简述

---

## ✅ 启动与退出
- 启动调试：
  ```bash
  gdb 可执行程序名
  ```
- 退出：
  ```gdb
  quit 或 q
  ```

---

## ✅ 设置程序参数
- 设置参数：
  ```gdb
  set args 10 20
  ```
- 查看参数：
  ```gdb
  show args
  ```

---

## ✅ GDB 帮助
- 获取帮助：
  ```gdb
  help
  ```

---

## ✅ 查看代码
- 当前文件：
  ```gdb
  list 或 l             # 默认位置开始
  list 行号             # 从指定行开始
  list 函数名           # 从指定函数开始
  ```
- 其他文件：
  ```gdb
  list 文件名:行号
  list 文件名:函数名
  ```

- 设置显示行数：
  ```gdb
  show listsize
  set listsize 行数
  ```

---

## ✅ 设置断点
- 普通断点：
  ```gdb
  break 行号
  break 函数名
  break 文件名:行号
  break 文件名:函数名
  ```
- 条件断点（常用于循环）：
  ```gdb
  break 10 if i == 5
  ```

---

## ✅ 管理断点
- 查看断点：
  ```gdb
  info break 或 i b
  ```
- 删除断点：
  ```gdb
  delete 编号 或 d 编号
  ```
- 禁用断点：
  ```gdb
  disable 编号
  ```
- 启用断点：
  ```gdb
  enable 编号
  ```

---

## ✅ 程序运行控制
- 启动并停在第一行：
  ```gdb
  start
  ```
- 正常运行（遇断点才停）：
  ```gdb
  run
  ```
- 继续运行到下一个断点：
  ```gdb
  continue 或 c
  ```
- 单步执行（不进入函数）：
  ```gdb
  next 或 n
  ```
- 单步执行（进入函数）：
  ```gdb
  step 或 s
  ```
- 跳出当前函数：
  ```gdb
  finish
  ```
- 跳出当前循环：
  ```gdb
  until
  ```

---

## ✅ 变量操作
- 打印变量值：
  ```gdb
  print 变量名 或 p 变量名
  ```
- 打印变量类型：
  ```gdb
  ptype 变量名
  ```
- 自动显示变量值：
  ```gdb
  display 变量名
  info display
  undisplay 编号
  ```
- 设置变量值：
  ```gdb
  set var 变量名=值
  ```

---

## ✅ 多进程调试相关
- 查看 `follow-fork-mode` 选项值：
  ```gdb
  show follow-fork-mode
  ```
- 设置 `follow-fork-mode`：
  ```gdb
  set follow-fork-mode parent | child
  ```
- 查看 `detach-on-fork` 选项值：
  ```gdb
  show detach-on-fork
  ```
- 设置 `detach-on-fork`：
  ```gdb
  set detach-on-fork on | off
  ```
- 查看当前调试中的进程数：
  ```gdb
  info inferiors
  ```
- 切换调试某个进程：
  ```gdb
  inferior 进程ID
  ```

---

## ✅ 总结 - 得分点
- 启动、退出命令
- 设置与查看参数
- 查看代码技巧（当前/非当前文件）
- 各类断点设置与管理（含条件断点）
- 运行控制（start、run、next、step、finish、until）
- 变量操作（print、ptype、display、set var）
- 多进程调试（fork 相关设置、inferiors）
- 其他命令简洁实用

# 常见的进程调度算法简述

进程调度算法是操作系统在多个进程竞争 CPU 时决定哪个进程获得处理机控制权的策略。常见的调度算法如下：

---

## 1. 先来先服务（FCFS）调度算法

- 最基本、最简单的调度算法。
- 按进程进入就绪队列的先后顺序来分配 CPU。
- 特点：
  - 实现简单，公平性好。
  - 但不考虑进程运行时间，可能导致短作业等待长时间。

---

## 2. 短作业优先（SJF）调度算法

- 优先选择**估计运行时间最短**的作业执行。
- 又称短进程优先（SPF）。
- 特点：
  - 平均等待时间最短。
  - 有利于提高系统吞吐量。
  - 但需要预知运行时间，且可能导致长作业“饥饿”。

---

## 3. 优先级调度算法

- 每个进程被赋予一个优先级。
- 调度时总是选择**优先级最高**的进程执行。
- 可分为**抢占式**和**非抢占式**两种。
- 特点：
  - 适用于对响应速度有要求的任务。
  - 低优先级进程可能一直得不到执行机会（可采用优先级老化机制缓解）。

---

## 4. 高响应比优先（HRRN）调度算法

- 兼顾等待时间和运行时间。
- 响应比计算公式：
  ```
  响应比 = （等待时间 + 运行时间）/ 运行时间
  ```
- 每次调度选择响应比最高的进程执行。
- 特点：
  - 综合考虑等待时间和作业长度。
  - 有效避免了 SJF 的“饥饿”问题。
  - 算法公平性和效率之间取得较好平衡。

---

## 5. 时间片轮转（RR）调度算法

- 适用于**分时系统**。
- 每个进程被分配一个固定的**时间片**。
- 执行一个时间片后将进程送回队尾。
- 特点：
  - 每个进程公平地获得 CPU 时间。
  - 时间片越小，响应速度越快，但上下文切换开销越大。

---

## 6. 多级反馈队列调度算法（MFQ）

- 结合了时间片轮转和优先级调度的优点。
- 设置多个就绪队列，不同队列有不同的优先级和时间片大小。
- 新进程从高优先级队列进入，若未完成则下降到低优先级队列。
- 特点：
  - 动态调整进程优先级。
  - 能兼顾**交互性好**和**长作业处理能力强**的目标。
  - 是现代操作系统中最常用的调度策略之一。

---

## ✅ 得分点总结

- 常见调度算法：FCFS、SJF、优先级、HRRN、RR、MFQ ✅
- 每种算法的特点与适用场景 ✅
- 体现调度算法的公平性、效率、响应性等考虑 ✅

# 什么是大端、小端？如何判断？

---

## ✅ 字节序（Endian）

字节序是指多字节数据在内存中的**存储顺序**。常见的有两种：

---

## 1. 大端字节序（Big-Endian）

- 高位字节存储在内存的**低地址**处，低位字节存储在**高地址**处。
- 举例：`0x0102` 存储为：
  ```
  地址低 --> 高
  [0x01] [0x02]
  ```

---

## 2. 小端字节序（Little-Endian）

- 低位字节存储在内存的**低地址**处，高位字节存储在**高地址**处。
- 举例：`0x0102` 存储为：
  ```
  地址低 --> 高
  [0x02] [0x01]
  ```

---

## 3. 如何判断当前系统是大端还是小端？

可以使用 `union` 联合体来实现：

### ✅ 示例代码：

```c
#include <stdio.h>

int main() {
    union {
        short value;
        char bytes[sizeof(short)];
    } test;

    test.value = 0x0102;

    if (test.bytes[0] == 1 && test.bytes[1] == 2) {
        printf("大端字节序\n");
    } else if (test.bytes[0] == 2 && test.bytes[1] == 1) {
        printf("小端字节序\n");
    } else {
        printf("未知字节序\n");
    }

    return 0;
}
```

---

## ✅ 总结（得分点）

- 字节序的概念（多字节数据的存储顺序）
- 大端：高位在低地址 ✅
- 小端：低位在低地址 ✅
- 使用 `union` 判断系统字节序 ✅

# 什么是孤儿进程、僵尸进程？如何解决僵尸进程？

---

## ✅ 1. 什么是孤儿进程（Orphan Process）

- 指的是：**父进程先于子进程退出**，而子进程还在运行。
- 此时，这些子进程就成为“孤儿”，由 **`init` 进程（进程号为 1）**接管。
- `init` 会负责对子进程进行**状态收集和资源回收**。
- ✅ **孤儿进程不会对系统造成危害**，因为最终还是会被处理。

---

## ✅ 2. 什么是僵尸进程（Zombie Process）

- 指的是：子进程已经退出，但是**父进程没有通过 `wait()` 或 `waitpid()` 收集子进程的退出状态**。
- 此时，子进程虽然不再运行，但其进程表项（PCB）还保留在系统中，造成**资源占用**。
- 如果父进程一直不处理，**系统中的僵尸进程将越来越多，最终可能耗尽进程表资源，影响新进程的创建。**

---

## ✅ 3. 如何解决僵尸进程

### 方法一：父进程主动调用 `wait()` 或 `waitpid()` 回收子进程资源
```c
pid_t pid = fork();
if (pid > 0) {
    // 父进程
    wait(NULL); // 等待子进程退出并回收资源
} else if (pid == 0) {
    // 子进程
    // ... do work
    exit(0);
}
```

### 方法二：使用 `SIGCHLD` 信号处理机制自动回收

- 当子进程退出时，内核会向父进程发送 `SIGCHLD` 信号。
- 父进程可以设置一个信号处理函数，来调用 `wait()` 或 `waitpid()`，从而清理僵尸进程：

```c
#include <signal.h>
#include <sys/wait.h>
#include <unistd.h>
#include <stdio.h>

void sigchld_handler(int sig) {
    while (waitpid(-1, NULL, WNOHANG) > 0);
}

int main() {
    signal(SIGCHLD, sigchld_handler);

    pid_t pid = fork();
    if (pid == 0) {
        // 子进程
        sleep(1);
        _exit(0);
    } else {
        // 父进程
        while (1) {
            pause(); // 等待信号
        }
    }
}
```

- `waitpid(-1, NULL, WNOHANG)` 会非阻塞地回收所有已退出的子进程。

---

## ✅ 得分点总结

| 关键点             | 内容                                                                 |
|------------------|----------------------------------------------------------------------|
| 孤儿进程定义         | 父进程退出、子进程仍在运行，被 `init` 收养                                      |
| 僵尸进程定义         | 子进程退出但父进程未 `wait()` 或 `waitpid()`，导致进程表项未清除，占用资源                |
| 解决方法一（主动）     | 父进程调用 `wait()` / `waitpid()` 手动回收子进程                                     |
| 解决方法二（被动）     | 捕获 `SIGCHLD` 信号，在信号处理函数中调用 `wait()` 或 `waitpid()` 实现自动回收             |

# 常见的进程通信方式有哪些？

进程间通信（IPC, Inter-Process Communication）是多个进程之间**交换数据或协同工作的机制**。常见的通信方式包括以下几种：

---

## ✅ 1. 管道（Pipe）

- 又称**匿名管道**，是最早的 UNIX IPC 机制。
- 通过 `pipe()` 创建，产生两个文件描述符：读端和写端。
- 特点：
  - 数据是**单向流动**的。
  - **只能用于有亲缘关系的进程**（如父子进程之间）。

---

## ✅ 2. 命名管道（FIFO）

- 是管道的进阶形式，**带有路径名**，存在于文件系统中。
- 通过 `mkfifo()` 创建。
- 特点：
  - 可以用于**无亲缘关系的进程之间通信**。
  - 通信方式仍为**单向**。

---

## ✅ 3. 信号（Signal）

- 最简单的通信方式，用于**通知进程某种事件发生**。
- 属于**异步通信**机制。
- 常用信号如 `SIGINT`（中断）、`SIGCHLD`（子进程退出）等。
- 特点：
  - 通信内容有限，只能表示事件类型。
  - 多用于中断通知、异常处理等场景。

---

## ✅ 4. 消息队列（Message Queue）

- 是一个**由内核维护的消息链表**。
- 进程可通过 `msgsnd()` 和 `msgrcv()` 向队列中写入/读取消息。
- 特点：
  - 支持消息的**格式和优先级**。
  - 消息传递可靠，数据结构丰富。

---

## ✅ 5. 共享内存（Shared Memory）

- **最快速的进程通信方式**。
- 多个进程可以**共享同一段物理内存**。
- 通常配合信号量实现同步。
- 特点：
  - 无需拷贝，效率高。
  - 要求进程自行管理并发和同步。

---

## ✅ 6. 内存映射（Memory-Mapped I/O）

- 将文件内容映射到内存中。
- 不同进程通过映射同一文件实现数据共享。
- 特点：
  - 既可用于进程间通信，也可实现文件读写加速。
  - 通信双方需打开同一个文件。

---

## ✅ 7. 信号量（Semaphore）

- 主要用于**进程/线程之间的同步与互斥**。
- 是一个整型计数器，支持原子操作（P/V 操作）。
- 特点：
  - 不传输数据，仅用于**控制资源访问顺序**。
  - 常与共享内存、管道等方式配合使用。

---

## ✅ 8. 套接字（Socket）

- 最强大、最灵活的通信方式，适用于**网络通信和本机跨进程通信**。
- 支持 TCP、UDP 等协议。
- 特点：
  - 可用于**不同主机间**的通信。
  - 也可以用作**本机进程间的双向通信机制**（UNIX 域套接字）。

---

## ✅ 得分点总结

| 通信方式   | 是否亲缘限制 | 是否跨主机 | 是否双向 | 是否支持同步控制 |
|------------|--------------|------------|----------|------------------|
| 管道       | 是           | 否         | 否       | 否               |
| 命名管道   | 否           | 否         | 否       | 否               |
| 信号       | 否           | 否         | 否       | 否               |
| 消息队列   | 否           | 否         | 是       | 部分支持         |
| 共享内存   | 否           | 否         | 是       | 需手动同步       |
| 内存映射   | 否           | 否         | 是       | 需手动同步       |
| 信号量     | 否           | 否         | 否       | 是               |
| Socket     | 否           | 是         | 是       | 支持             |

# 进程有多少种状态？如何转换？

---

## ✅ 1. 五种基本状态

| 状态 | 描述 |
|------|------|
| **创建（Create）** | 进程被创建后，开始申请资源，建立 PCB（进程控制块）。 |
| **就绪（Ready）** | 进程已准备好，但暂未获得 CPU。 |
| **运行（Running）** | 进程获得 CPU 正在执行。 |
| **阻塞（Blocked）** | 进程等待某个事件（如 I/O 结束）而挂起，不能运行。 |
| **终止（Terminated）** | 进程正常结束或被强制终止，资源被释放。 |

---

## ✅ 2. 状态转换说明

进程在系统中运行时，状态之间可以发生如下转换（对应图示）：

1. **创建 → 就绪**：进程创建成功，资源分配完成后进入就绪队列。
2. **就绪 → 运行**：调度器为其分配 CPU。
3. **运行 → 就绪**：时间片用完，主动放弃 CPU。
4. **运行 → 阻塞**：等待某个事件，如 I/O 操作。
5. **阻塞 → 就绪**：等待的事件完成，重新回到就绪队列。
6. **运行 → 终止**：进程执行结束或被系统终止。
7. **就绪 → 运行 → 阻塞 → 就绪 → 运行 → 终止**：是一个典型完整生命周期。

---

## ✅ 3. 配图说明（进程状态转换图）

这张图展示了进程在不同状态之间的典型转换路径：

![进程状态转换图](/image/process_state.png)

图中各状态及转换路径说明如下：

- `创建` → `就绪`：允许调度，准备运行。
- `就绪` → `运行`：被调度获得 CPU。
- `运行` → `阻塞`：等待资源（如 I/O）。
- `阻塞` → `就绪`：等待结束，重新准备执行。
- `运行` → `就绪`：时间片耗尽，被挂起。
- `运行` → `终止`：执行完毕或被终止。

---

## ✅ 得分点总结

- 五种基本状态：创建、就绪、运行、阻塞、终止 ✅  
- 状态之间的转换条件清晰 ✅  
- 配图支持直观理解 ✅  

# 请你说说线程的通信方式

---

## ✅ 总体思路

- 与进程不同，**线程间通信不需要特殊机制**，因为同一进程内的所有线程共享：
  - 全局变量
  - 堆内存
  - 静态数据区等

- 所以线程通信非常简单：**直接读写共享内存即可**。

- 但共享带来了并发问题，因此我们需要各种**同步机制**来保证线程安全。

---

## ✅ 常见线程通信与同步机制

### 1. 信号（Signal）

- 可使用 `pthread_kill()` 给指定线程发送信号。
- 用于通知、唤醒线程处理某些事件。
- 不用于数据通信，常用于事件驱动。

```c
pthread_kill(thread_id, SIGUSR1);
```

---

### 2. 互斥锁（Mutex）

- `pthread_mutex_t` 是最常用的同步方式。
- 确保**同一时刻只有一个线程访问共享资源**。

```c
pthread_mutex_lock(&mutex);
// 访问共享资源
pthread_mutex_unlock(&mutex);
```

---

### 3. 读写锁（Read-Write Lock）

- 允许多个线程同时读，写操作互斥。
- 适用于“读多写少”的场景，提升并发性能。

```c
pthread_rwlock_rdlock(&rwlock);   // 读锁
pthread_rwlock_wrlock(&rwlock);   // 写锁
pthread_rwlock_unlock(&rwlock);
```

---

### 4. 自旋锁（Spinlock）

- 尝试加锁失败时，不阻塞，而是持续尝试获取（"自旋"）。
- **适用于锁占用时间很短**的场景，避免线程切换带来的性能损耗。

```c
pthread_spin_lock(&spinlock);
// 临界区
pthread_spin_unlock(&spinlock);
```

---

### 5. 条件变量（Condition Variable）

- 条件变量允许线程**等待某个条件成立**再继续执行。
- 与互斥锁搭配使用，可实现**线程间的等待/通知机制**。

```c
pthread_mutex_lock(&mutex);
while (!condition) {
    pthread_cond_wait(&cond, &mutex);
}
// 条件满足后继续执行
pthread_mutex_unlock(&mutex);
```

---

### 6. 信号量（Semaphore）

- 本质是一个**计数器**，控制资源访问的线程数量。
- 适用于**限制并发数量**的场景，如线程池、数据库连接池等。

```c
sem_wait(&sem);   // P操作，资源-1
// 使用资源
sem_post(&sem);   // V操作，资源+1
```

---

## ✅ 总结：线程通信方式与适用场景

| 通信方式     | 是否传递数据 | 是否同步 | 适用场景                     |
|--------------|--------------|----------|------------------------------|
| 共享内存     | ✅           | ❌       | 所有线程共用地址空间          |
| 信号         | ❌           | ✅       | 异步通知线程处理事件          |
| 互斥锁       | ❌           | ✅       | 多线程互斥访问临界资源        |
| 读写锁       | ❌           | ✅       | 多读少写并发访问              |
| 自旋锁       | ❌           | ✅       | 锁等待时间短，不希望阻塞      |
| 条件变量     | ❌           | ✅       | 线程等待某条件满足            |
| 信号量       | ❌           | ✅       | 控制线程/资源使用数量         |


# 进程和线程的区别

进程（Process）和线程（Thread）是操作系统中进行并发执行的两个基本单位，它们的主要区别在于资源管理和调度方式不同。

---

## ✅ 1. 地址空间

- **进程**：拥有**独立的地址空间**，各个进程间内存完全隔离。
- **线程**：同属一个进程的多个线程**共享进程的地址空间**，但各自有独立的栈空间和寄存器。

---

## ✅ 2. 创建与切换开销

- **进程**：创建/销毁/切换需要较多的系统资源（如内存、文件描述符等）。
- **线程**：创建/销毁/切换更轻量，系统开销更小。

👉 所以线程的上下文切换速度远快于进程。

---

## ✅ 3. 并发性

- **进程**：并发能力较低，适合隔离性强的任务。
- **线程**：并发能力强，适合密集型协作任务。

---

## ✅ 4. 执行与调度

- **进程**：是操作系统资源分配的基本单位，有独立的入口、执行序列、退出点。
- **线程**：依附于进程，不能独立存在，由程序控制调度多个线程。

---

## ✅ 5. 资源分配方式

- **进程**：系统为每个进程分配独立的资源，如内存空间、文件描述符等。
- **线程**：线程共享其所属进程的所有资源，如代码段、数据段、打开文件等。

---

## ✅ 6. 稳定性与健壮性

- **进程**：一个进程崩溃不会影响其他进程，更加健壮。
- **线程**：一个线程崩溃可能导致整个进程终止，风险更高。

---

## ✅ 总结对比表

| 项目           | 进程（Process）                    | 线程（Thread）                     |
|----------------|-------------------------------------|-------------------------------------|
| 地址空间       | 独立                               | 共享（但栈空间独立）               |
| 创建/切换开销   | 大（慢）                            | 小（快）                            |
| 并发性         | 较低                               | 较高                                |
| 调度单位       | 操作系统资源分配单位               | 程序执行的最小单位                 |
| 执行关系       | 独立运行                           | 依赖于进程，不能单独存在           |
| 资源隔离       | 完全隔离                           | 共享大部分资源                     |
| 崩溃影响范围   | 不影响其他进程                     | 可能导致整个进程崩溃               |

---

## ✅ 实际应用建议

- 使用**多进程**：适用于任务间独立性强、稳定性要求高的场景，如服务隔离、分布式系统等。
- 使用**多线程**：适用于共享数据、多任务协同、性能要求高的场景，如 Web 服务器、图像处理等。


# 线程和协程的区别

线程（Thread）和协程（Coroutine）都是并发编程中的常见概念，它们的核心区别在于**资源占用、调度方式和执行模型**不同：

---

## ✅ 1. 所属层级

- **线程**：操作系统内核级资源，由操作系统调度和管理。
- **协程**：运行在用户态，**由程序自身调度**，不依赖操作系统线程调度机制，因此又称“用户态线程”。

---

## ✅ 2. 创建和切换开销

- **线程**：创建和切换需要系统调用，涉及上下文切换，**开销较大**。
- **协程**：创建/切换在用户空间完成，不需内核参与，**轻量级**，非常高效。

---

## ✅ 3. 并发与并行

- **线程**：在多核 CPU 上可实现真正的**并行**执行。
- **协程**：**并发**模型，同一时刻只能一个协程在运行，适合 I/O 密集型任务。

---

## ✅ 4. 调度机制

- **线程**：**抢占式调度**，由操作系统控制，线程之间互不知情。
- **协程**：**协作式调度**，只能在协程代码中“主动让出”控制权。

---

## ✅ 5. 编程模型

- **线程**：同步模型，适合 CPU 密集型任务。
- **协程**：异步模型，适合 I/O 密集型任务，如网络请求、数据库访问等。

---

## ✅ 6. 数量对比

- **线程**：受限于系统资源，通常上限为几千个线程。
- **协程**：占用资源极少，**可轻松创建上万个协程**，适合高并发场景。

---

## ✅ 总结对比表

| 对比项           | 线程（Thread）                | 协程（Coroutine）              |
|------------------|-------------------------------|-------------------------------|
| 所属层级         | 内核级（Kernel Space）        | 用户级（User Space）          |
| 创建/切换开销    | 高（系统调用）                 | 低（用户态切换）              |
| 并发/并行        | 支持并行（多核）               | 支持并发（单线程）            |
| 调度方式         | 操作系统调度（抢占式）         | 程序主动调度（协作式）        |
| 适用场景         | CPU 密集任务                  | I/O 密集任务、高并发网络应用  |
| 数量限制         | 千级别                         | 万级别甚至更多                |

---

## ✅ 一句话总结

> **线程是由操作系统调度的重量级单位，适合并行计算；协程是由用户控制调度的轻量级单位，适合高并发异步场景。**





























