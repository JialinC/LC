# 静态库与动态库的制作与使用

---

## 1. 静态库（Static Library）

### ✅ 命名规则  
- **Linux**: `libxxx.a`  
  - `lib`: 固定前缀  
  - `xxx`: 库名称（自定义）  
  - `.a`: 后缀  
- **Windows**: `libxxx.lib`

### ✅ 制作流程  
1. **编译源文件为目标文件（.o）**  
   ```bash
   gcc -c a.c b.c
   ```

2. **使用 ar 工具打包为静态库**  
   ```bash
   ar rcs libxxx.a a.o b.o
   ```

### ✅ 使用方法  
编译主程序时链接静态库：  
```bash
gcc main.c -L. -lxxx -o main
```
说明：  
- `-L.` 指定库所在路径  
- `-lxxx` 链接名为 `libxxx.a` 的库  

---

## 2. 动态库（Dynamic Library）

### ✅ 命名规则  
- **Linux**: `libxxx.so`  
  - `lib`: 固定前缀  
  - `xxx`: 自定义名  
  - `.so`: 动态库后缀  
- **Windows**: `libxxx.dll`

### ✅ 制作流程  
1. **编译为位置无关代码（fPIC）**  
   ```bash
   gcc -fPIC -c a.c b.c
   ```

2. **生成共享库（.so）**  
   ```bash
   gcc -shared a.o b.o -o libxxx.so
   ```

### ✅ 使用方法  
编译主程序：  
```bash
gcc main.c -L. -lxxx -o main
```
运行程序前设置动态库路径：  
```bash
export LD_LIBRARY_PATH=.
```

---

## 3. 静态库 vs 动态库

| 特性 | 静态库 `.a` | 动态库 `.so` |
|------|-------------|---------------|
| 链接方式 | 编译时链接 | 运行时链接 |
| 是否打包进程序 | 是 | 否 |
| 发布是否需额外库 | 否 | 是 |
| 内存占用 | 高（每个程序各自加载） | 低（共享加载） |
| 更新方式 | 需重新编译程序 | 可直接替换库 |
| 优点 | 移植方便，无依赖 | 更新方便，节省空间 |
| 缺点 | 更新麻烦，程序体积大 | 运行环境需有库文件 |

---

## 🎯 得分点总结
- ✅ 命名规范清楚
- ✅ 制作命令齐全：`gcc -c`, `ar`, `-fPIC`, `-shared`
- ✅ 使用方式包含 `-L`, `-l`，和 `LD_LIBRARY_PATH`
- ✅ 对比有条理，涵盖运行机制、部署、内存等方面

# GDB 常见调试命令简述

---

## ✅ 启动与退出
- 启动调试：
  ```bash
  gdb 可执行程序名
  ```
- 退出：
  ```gdb
  quit 或 q
  ```

---

## ✅ 设置程序参数
- 设置参数：
  ```gdb
  set args 10 20
  ```
- 查看参数：
  ```gdb
  show args
  ```

---

## ✅ GDB 帮助
- 获取帮助：
  ```gdb
  help
  ```

---

## ✅ 查看代码
- 当前文件：
  ```gdb
  list 或 l             # 默认位置开始
  list 行号             # 从指定行开始
  list 函数名           # 从指定函数开始
  ```
- 其他文件：
  ```gdb
  list 文件名:行号
  list 文件名:函数名
  ```

- 设置显示行数：
  ```gdb
  show listsize
  set listsize 行数
  ```

---

## ✅ 设置断点
- 普通断点：
  ```gdb
  break 行号
  break 函数名
  break 文件名:行号
  break 文件名:函数名
  ```
- 条件断点（常用于循环）：
  ```gdb
  break 10 if i == 5
  ```

---

## ✅ 管理断点
- 查看断点：
  ```gdb
  info break 或 i b
  ```
- 删除断点：
  ```gdb
  delete 编号 或 d 编号
  ```
- 禁用断点：
  ```gdb
  disable 编号
  ```
- 启用断点：
  ```gdb
  enable 编号
  ```

---

## ✅ 程序运行控制
- 启动并停在第一行：
  ```gdb
  start
  ```
- 正常运行（遇断点才停）：
  ```gdb
  run
  ```
- 继续运行到下一个断点：
  ```gdb
  continue 或 c
  ```
- 单步执行（不进入函数）：
  ```gdb
  next 或 n
  ```
- 单步执行（进入函数）：
  ```gdb
  step 或 s
  ```
- 跳出当前函数：
  ```gdb
  finish
  ```
- 跳出当前循环：
  ```gdb
  until
  ```

---

## ✅ 变量操作
- 打印变量值：
  ```gdb
  print 变量名 或 p 变量名
  ```
- 打印变量类型：
  ```gdb
  ptype 变量名
  ```
- 自动显示变量值：
  ```gdb
  display 变量名
  info display
  undisplay 编号
  ```
- 设置变量值：
  ```gdb
  set var 变量名=值
  ```

---

## ✅ 多进程调试相关
- 查看 `follow-fork-mode` 选项值：
  ```gdb
  show follow-fork-mode
  ```
- 设置 `follow-fork-mode`：
  ```gdb
  set follow-fork-mode parent | child
  ```
- 查看 `detach-on-fork` 选项值：
  ```gdb
  show detach-on-fork
  ```
- 设置 `detach-on-fork`：
  ```gdb
  set detach-on-fork on | off
  ```
- 查看当前调试中的进程数：
  ```gdb
  info inferiors
  ```
- 切换调试某个进程：
  ```gdb
  inferior 进程ID
  ```

---

## ✅ 总结 - 得分点
- 启动、退出命令
- 设置与查看参数
- 查看代码技巧（当前/非当前文件）
- 各类断点设置与管理（含条件断点）
- 运行控制（start、run、next、step、finish、until）
- 变量操作（print、ptype、display、set var）
- 多进程调试（fork 相关设置、inferiors）
- 其他命令简洁实用

# 常见的进程调度算法简述

进程调度算法是操作系统在多个进程竞争 CPU 时决定哪个进程获得处理机控制权的策略。常见的调度算法如下：

---

## 1. 先来先服务（FCFS）调度算法

- 最基本、最简单的调度算法。
- 按进程进入就绪队列的先后顺序来分配 CPU。
- 特点：
  - 实现简单，公平性好。
  - 但不考虑进程运行时间，可能导致短作业等待长时间。

---

## 2. 短作业优先（SJF）调度算法

- 优先选择**估计运行时间最短**的作业执行。
- 又称短进程优先（SPF）。
- 特点：
  - 平均等待时间最短。
  - 有利于提高系统吞吐量。
  - 但需要预知运行时间，且可能导致长作业“饥饿”。

---

## 3. 优先级调度算法

- 每个进程被赋予一个优先级。
- 调度时总是选择**优先级最高**的进程执行。
- 可分为**抢占式**和**非抢占式**两种。
- 特点：
  - 适用于对响应速度有要求的任务。
  - 低优先级进程可能一直得不到执行机会（可采用优先级老化机制缓解）。

---

## 4. 高响应比优先（HRRN）调度算法

- 兼顾等待时间和运行时间。
- 响应比计算公式：
  ```
  响应比 = （等待时间 + 运行时间）/ 运行时间
  ```
- 每次调度选择响应比最高的进程执行。
- 特点：
  - 综合考虑等待时间和作业长度。
  - 有效避免了 SJF 的“饥饿”问题。
  - 算法公平性和效率之间取得较好平衡。

---

## 5. 时间片轮转（RR）调度算法

- 适用于**分时系统**。
- 每个进程被分配一个固定的**时间片**。
- 执行一个时间片后将进程送回队尾。
- 特点：
  - 每个进程公平地获得 CPU 时间。
  - 时间片越小，响应速度越快，但上下文切换开销越大。

---

## 6. 多级反馈队列调度算法（MFQ）

- 结合了时间片轮转和优先级调度的优点。
- 设置多个就绪队列，不同队列有不同的优先级和时间片大小。
- 新进程从高优先级队列进入，若未完成则下降到低优先级队列。
- 特点：
  - 动态调整进程优先级。
  - 能兼顾**交互性好**和**长作业处理能力强**的目标。
  - 是现代操作系统中最常用的调度策略之一。

---

## ✅ 得分点总结

- 常见调度算法：FCFS、SJF、优先级、HRRN、RR、MFQ ✅
- 每种算法的特点与适用场景 ✅
- 体现调度算法的公平性、效率、响应性等考虑 ✅

# 什么是大端、小端？如何判断？

---

## ✅ 字节序（Endian）

字节序是指多字节数据在内存中的**存储顺序**。常见的有两种：

---

## 1. 大端字节序（Big-Endian）

- 高位字节存储在内存的**低地址**处，低位字节存储在**高地址**处。
- 举例：`0x0102` 存储为：
  ```
  地址低 --> 高
  [0x01] [0x02]
  ```

---

## 2. 小端字节序（Little-Endian）

- 低位字节存储在内存的**低地址**处，高位字节存储在**高地址**处。
- 举例：`0x0102` 存储为：
  ```
  地址低 --> 高
  [0x02] [0x01]
  ```

---

## 3. 如何判断当前系统是大端还是小端？

可以使用 `union` 联合体来实现：

### ✅ 示例代码：

```c
#include <stdio.h>

int main() {
    union {
        short value;
        char bytes[sizeof(short)];
    } test;

    test.value = 0x0102;

    if (test.bytes[0] == 1 && test.bytes[1] == 2) {
        printf("大端字节序\n");
    } else if (test.bytes[0] == 2 && test.bytes[1] == 1) {
        printf("小端字节序\n");
    } else {
        printf("未知字节序\n");
    }

    return 0;
}
```

---

## ✅ 总结（得分点）

- 字节序的概念（多字节数据的存储顺序）
- 大端：高位在低地址 ✅
- 小端：低位在低地址 ✅
- 使用 `union` 判断系统字节序 ✅
