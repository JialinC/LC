# 1. Java基础

## 1.1 为什么Java代码可以实现一次编写、到处运行？
**参考答案**

JVM（Java虚拟机）是Java跨平台的关键。

- 在程序运行前，Java源代码（`.java`）需要经过编译器编译成字节码（`.class`）。
- 在程序运行时，JVM负责将字节码翻译成特定平台下的机器码并运行。
- 只要在不同的平台上安装对应的JVM，就可以运行字节码文件。

**注意事项**

- 编译的结果是生成字节码，而不是机器码，字节码不能直接运行，必须通过JVM翻译成机器码才能运行。
- 跨平台的是Java程序，而不是JVM。JVM是用C/C++开发的软件，不同平台下需要安装不同版本的JVM。

---

## 1.2 一个Java文件里可以有多个类吗（不含内部类）？
**参考答案**

- 一个Java文件里可以有多个类，但最多只能有一个被`public`修饰的类。
- 如果Java文件中包含`public`修饰的类，则这个类的名称必须和Java文件名一致。

---

## 1.3 说一说你对Java访问权限的了解
**参考答案**

Java语言提供了三种访问修饰符：`private`、`protected`、`public`，以及默认访问权限`default`。这些修饰符可以形成四种访问权限：

- **private**：仅允许类内部访问。
- **default**：允许同一包下的其他类访问。
- **protected**：允许同一包下的其他类以及子类访问。
- **public**：允许任意包下的任意类访问。

### 类的访问权限
- **default**：类可以被同一包下的其他类访问。
- **public**：类可以被任意包下的任意类访问。

---

## 1.4 介绍一下Java的数据类型
**参考答案**

Java数据类型包括：

- **基本数据类型**（8种）
  - 整数类型：`byte`、`short`、`int`、`long`
  - 浮点类型：`float`、`double`
  - 字符类型：`char`
  - 布尔类型：`boolean`
- **引用数据类型**：包括数组、类、接口类型。

### 扩展阅读
基本数据类型的内存占用：

- `byte`：1字节（8位），-2^7 ~ 2^7-1
- `short`：2字节（16位），-2^15 ~ 2^15-1
- `int`：4字节（32位），-2^31 ~ 2^31-1
- `long`：8字节（64位），-2^63 ~ 2^63-1
- `float`：4字节（32位），约 -3.4 × 10^38 ~ 3.4 × 10^38
- `double`：8字节（64位），约 -1.8 × 10^308 ~ 1.8 × 10^308
- `char`：2字节（16位），\u0000 ~ \uffff
- `boolean`：内存大小由JVM实现决定

---

## 1.5 int类型的数据范围是多少？
**参考答案**

- `int`类型占4字节（32位），数据范围是`-2^31` ~ `2^31 - 1`。

---

## 1.6 请介绍全局变量和局部变量的区别
**参考答案**

Java中变量分为**成员变量**和**局部变量**：

### 成员变量
- 定义在类的范围内。
- 有默认初始值。
- **实例变量**：未被`static`修饰，存储于堆内存中，生命周期与对象相同。
- **类变量**：被`static`修饰，存储于方法区中，生命周期与类相同。

### 局部变量
- 定义在方法或代码块中。
- 没有默认初始值。
- 存储于栈内存，生命周期结束后自动释放。

**注意事项**

Java中没有真正的全局变量，面试官的“全局变量”通常是指成员变量。

---

## 1.7 请介绍一下实例变量的默认值
**参考答案**

- **引用数据类型**：默认值为`null`。
- **基本数据类型**默认值：

| 数据类型  | 默认值   |
|--------|--------|
| `byte` | 0      |
| `short`| 0      |
| `int`  | 0      |
| `long` | 0L     |
| `float`| 0.0F   |
| `double`| 0.0   |
| `char` | '\u0000' |
| `boolean` | false |

---

## 1.8 为啥要有包装类？
**参考答案**

Java是面向对象的语言，但8种基本数据类型不具备对象的特性。Java为每个基本数据类型都定义了一个对应的引用类型，这就是**包装类**。

### 扩展阅读
- 包装类的存在使基本数据类型可以作为`Object`类型进行处理，简化了代码操作，解决了基本类型和对象类型之间的转换问题。

---

## 1.9 说一说自动装箱、自动拆箱的应用场景
**参考答案**

自动装箱、自动拆箱是JDK1.5提供的功能。

- **自动装箱**：将基本类型直接赋值给对应的包装类。
- **自动拆箱**：将包装类对象直接赋值给基本类型。

### 应用场景
- 调用方法时，参数需要包装类型，可以直接传入基本类型。
- 进行集合操作时，可以将基本类型直接放入`List`、`Map`等集合。

---

## 1.10 如何对Integer和Double类型判断相等？
**参考答案**

`Integer`、`Double`不能直接进行比较，正确的比较方法：

- 不能使用`==`，因为它们是不同的数据类型。
- 不能通过字符串转换比较，因为浮点值带小数点，整数值不带。
- 不能使用`compareTo`进行比较，不同类型无法比较。

### 正确方法
- 将`Integer`、`Double`转换为相同的基本数据类型（如`double`），然后使用`==`进行比较。
```java
Integer intVal = 5;
Double doubleVal = 5.0;

if (intVal.doubleValue() == doubleVal) {
    System.out.println("相等");
}
```



## 1.11 int 和 Integer 有什么区别，二者在做 `==` 运算时会得到什么结果？
**参考答案**

- `int` 是基本数据类型，`Integer` 是 `int` 的包装类。
- 二者在做 `==` 运算时，`Integer` 会自动拆箱为 `int` 类型，然后再进行比较。
- 如果两个 `int` 值相等，则返回 `true`，否则返回 `false`。

---

## 1.12 说一说你对面向对象的理解
**参考答案**

面向对象是一种更优秀的程序设计方法，基本思想是使用 **类、对象、继承、封装、消息** 等基本概念进行程序设计。它从现实世界中客观存在的事物出发来构造软件系统，并在系统构造中尽可能运用人类的自然思维方式。

### 扩展阅读

- **结构化程序设计方法：**
  - 按功能分析系统需求，主要原则是 **自顶向下、逐步求精、模块化**。
  - 采用结构化分析方法进行需求分析，再使用结构化设计进行概要设计和详细设计，最后采用结构化编程实现系统。

- **结构化程序设计的局限性：**
  - 设计不够直观，与人类习惯思维不一致。
  - 适应性差，可扩展性不强，修改需求时需要自顶向下重新修改模块结构。

---

## 1.13 面向对象的三大特征是什么？
**参考答案**

面向对象的程序设计方法具有三个基本特征：**封装、继承、多态**。

- **封装：** 将对象的实现细节隐藏，通过一些公用方法暴露功能。
- **继承：** 子类继承父类后，子类作为一种特殊的父类，将直接获得父类的属性和方法。
- **多态：** 子类对象可以直接赋给父类变量，但运行时依然表现出子类的行为特征。

---

## 1.14 封装的目的是什么，为什么要有封装？
**参考答案**

封装是面向对象编程语言对客观世界的模拟，在客观世界里，对象的状态信息都被隐藏在对象内部，外界无法直接操作和修改。对一个类或对象实现良好的封装，可以实现以下目的：

- 隐藏类的实现细节；
- 让使用者只能通过事先预定的方法来访问数据，从而可以在该方法里加入控制逻辑，限制对成员变量的不合理访问；
- 可进行数据检查，从而有利于保证对象信息的完整性；
- 便于修改，提高代码的可维护性。

---

### 扩展阅读

为了实现良好的封装，需要从两个方面考虑：

1. 将对象的成员变量和实现细节隐藏起来，不允许外部直接访问；
2. 把方法暴露出来，让方法来控制对这些成员变量进行安全的访问和操作。

---

封装实际上有两个方面的含义：
- 把该隐藏的隐藏起来；
- 把该暴露的暴露出来。

这两个方面都需要通过使用 Java 提供的访问控制符来实现。

## 1.15 说一说你对多态的理解
**参考答案**

因为子类其实是一种特殊的父类，因此 Java 允许把一个子类对象直接赋给一个父类引用变量，无须任何类型转换，或者被称为**向上转型**，向上转型由系统自动完成。

当把一个子类对象直接赋给父类引用变量时，例如：

```java
BaseClass obj = new SubClass();
```

- `obj` 引用变量的**编译时类型**是 `BaseClass`，而**运行时类型**是 `SubClass`。
- 当运行时调用该引用变量的方法时，其方法行为总是表现出子类方法的行为特征，而不是父类方法的行为特征。
- 这种现象是：**相同类型的变量、调用同一个方法时呈现出多种不同的行为特征，这就是多态。**

---

### 扩展阅读

多态可以提高程序的**可扩展性**，在设计程序时让代码更加简洁而优雅。

---

### 示例

例如我要设计一个司机类，他可以开轿车、巴士、卡车等等，示例代码如下：

```java
class Driver {
    void drive(Car car) { ... }
    void drive(Bus bus) { ... }
    void drive(Truck truck) { ... }
}
```

在设计上述代码时，我已采用了**重载机制**，将方法名进行了统一。这样在进行调用时，无论要开什么交通工具，都是通过 `driver.drive(obj)` 这样的方式来调用，对调用者足够的友好。

---

### 问题

但对于程序的开发者来说，这显得繁琐，因为实际上这个司机可以驾驶更多的交通工具。当系统需要为这个司机增加车型时，开发者就需要相应的增加 `driver` 方法，类似的代码会堆积的越来越多，显得臃肿。

---

### 解决方案：使用多态

采用多态的方式来设计上述程序，就会变得简洁很多。我们可以为所有的交通工具定义一个父类 `Vehicle`，然后按照如下的方式设计 `drive` 方法。调用时，我们可以传入 `Vehicle` 类型的实例，也可以传入任意的 `Vehicle` 子类型的实例，对于调用者来说一样的方便，但对于开发者来说，代码却变得十分的简洁了。

```java
class Driver {
    void drive(Vehicle vehicle) { ... }
}
```

## 1.16 Java中的多态是怎么实现的？
**参考答案**

多态的实现离不开**继承**。在设计程序时，我们可以将参数的类型定义为父类型。在调用程序时，则可以根据实际情况，传入该父类型的某个子类型的实例，这样就实现了多态。

- **父类型**可以有三种形式：普通类、抽象类、接口。
- **子类型**需要根据自身的特征，重写父类的某些方法，或实现抽象类/接口的某些抽象方法。

---

## 1.17 Java为什么是单继承，为什么不能多继承？
**参考答案**

- Java 是**单继承**的，这意味着 Java 中一个类只能有一个直接的父类。
- Java 不支持**多继承**，即 Java 中一个类不能直接继承多个父类。

### 关键原因
- Java 在设计时借鉴了 C++ 的语法，而 C++ 是支持多继承的。
- Java 之所以摒弃了多继承的特性，是因为多继承容易产生混淆。例如：
    - 如果两个父类中包含相同的方法，子类在调用该方法或重写该方法时会产生**二义性**。

---

### 实现“多继承”的变通方法
Java 通过**接口**来实现类似于多继承的功能。
- **一个类可以实现多个接口**，从而达到某种程度上的多继承效果。
- 另外，Java 一个类只能有一个直接父类，但是却可以有任意多个间接父类，从而避免了多继承时产生的混淆。

---

## 1.18 说一说重写与重载的区别
**参考答案**

| 特性       | 重载（Overload）                  | 重写（Override）                   |
|----------|--------------------------|---------------------------|
| 发生位置    | 同一个类                  | 父类和子类                  |
| 方法签名    | 方法名相同，参数列表不同          | 方法名、参数列表相同            |
| 返回类型    | 无关                   | 子类返回类型 <= 父类返回类型 |
| 访问修饰符   | 无关                   | 子类的访问权限 >= 父类         |
| 关键字     | 不需要使用 `@Override`    | 需要使用 `@Override` 标注     |
| 目的       | 提供不同参数类型的多种实现    | 子类重写父类方法，提供不同实现   |

---

## 1.19 构造方法能不能重写？
**参考答案**

- **构造方法不能重写**。因为构造方法需要与类名保持一致，而重写的要求是子类方法与父类方法同名。
- 如果允许构造方法重写，那么子类中将会存在与类名不同的构造方法，这与构造方法的要求是矛盾的。

---

## 1.20 介绍一下Object类中的方法
**参考答案**

`Object` 类提供了以下几个常用方法：

- `Class<?> getClass()`：返回该对象的运行时类。
- `boolean equals(Object obj)`：判断指定对象与该对象是否相等。
- `int hashCode()`：返回该对象的 `hashCode` 值。默认情况下，`Object` 类的 `hashCode()` 方法根据该对象的地址计算，但很多类重写了 `hashCode()` 方法。
- `String toString()`：返回该对象的字符串表示。当程序使用 `System.out.println()` 输出一个对象时，系统会自动调用 `toString()` 方法。`Object` 类的 `toString()` 方法返回**运行时类名@十六进制 hashCode 值**格式的字符串，但很多类重写了 `toString()` 方法来返回更有意义的信息。

---

### 线程相关方法
- `void wait()`：让当前线程等待，直到被其他线程通知或超时。
- `void notify()`：唤醒一个正在等待的线程。
- `void notifyAll()`：唤醒所有正在等待的线程。

---

### `clone()` 方法
- `Object` 类提供了一个 `clone()` 方法，该方法用于创建一个对象的副本，并且副本与原对象完全隔离。
- 由于 `clone()` 方法使用了 `protected` 修饰，因此它只能被子类重写或调用。

---

### 扩展阅读
`Object` 类还提供了一个 `finalize()` 方法：

- 当系统中没有引用变量引用到该对象时，垃圾回收器调用此方法来清理该对象的资源。
- 垃圾回收器最多只会调用一个对象的 `finalize()` 方法一次。
- **注意：** `finalize()` 方法的调用时间和是否调用是不确定的，因此不要依赖 `finalize()` 方法来释放资源。从 JDK9 开始，该方法已被标记为不推荐使用。
















